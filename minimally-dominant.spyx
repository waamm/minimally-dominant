""" 
This code can be used to compute the set of dominant or minimally dominant elements of a conjugacy
class of a Weyl group W.
The final function in this file produces for such W a list of pairs of words (in GAP notation)
representing two elements for each (nonelliptic and nontrivial) conjugacy class of W: the first is
of minimal length and the second one is minimally dominant.

Input is:
. A Weyl group W (which in most of the auxiliary functions below is assumed to be acting on its
root lattice)

Input example:
> W = WeylGroup(["B",3])
> compute_pairs_of_min_length_and_min_dom_elts(W) 
"""


def minimal_length_elts_of_set(X):
    min_length = min({x.length() for x in X})
    return {x for x in X if x.length() == min_length}


def minimally_dominant_elements_of_conjugacy_class(W, V, dominant_weyl_chamber, X):
    ans = set()
    min_dom_length = W.long_element().length()
    for w in X:
        if w.length() <= min_dom_length:
            if is_dominant(W, V, dominant_weyl_chamber, w):
                if w.length() < min_dom_length:
                    min_dom_length = w.length()
                    ans = {w}
                else:
                    ans.add(w)
    return ans


def is_dominant(W, V, dominant_weyl_chamber, w):
    if w.reflection_length() == W.rank() or w.is_one():
        return True
    Vw = V_w(W, V, w)
    return Vw == V.span(intersect_closure_cone_with_subspace(dominant_weyl_chamber, Vw))


def dominant_weyl_chamber_in_root_basis(W):
    return list(CartanMatrix(W.cartan_type()).inverse().transpose())


def intersect_closure_cone_with_subspace(cone_rays, subspace):
    cone = Polyhedron(rays=cone_rays, base_ring=AA)
    intersected_cone = cone.intersection(Polyhedron(lines=subspace.basis(), base_ring=AA))
    return [ray.vector() for ray in intersected_cone.rays()]


def V_w(W, V, w):
    return V.span((w.to_matrix() - matrix.identity(W.rank())).columns())


def convert_word_from_bourbaki_to_gap(cartan_type, word):
    rk = cartan_type[1]
    if cartan_type[0] in {'B', 'C', 'D'}:
        dic = {i: rk - i + 1 for i in range(1, rk+1)}
    if cartan_type[0] in {'A', 'E', 'F', 'G'}:
        dic = {i: i for i in range(1, rk+1)}
    return [dic[word[i]] for i in range(len(word))]


def gap_word_of_elt(cartan_type, w):
    return convert_word_from_bourbaki_to_gap(cartan_type, w.reduced_word())


def compute_pairs_of_min_length_and_min_dom_elts(W):
    W = WeylGroup(RootSystem(W.cartan_type()).root_lattice())
    V = VectorSpace(AA, W.rank())
    cartan_type = W.cartan_type()
    dominant_weyl_chamber = dominant_weyl_chamber_in_root_basis(W)
    L = []
    for O in W.conjugacy_classes():
        if O[0].reflection_length() not in {0, W.rank()}:
            for x in minimal_length_elts_of_set(O):
                break
            for y in minimally_dominant_elements_of_conjugacy_class(
                W, V, dominant_weyl_chamber, O):
                break
            word_pair = tuple(gap_word_of_elt(cartan_type, w) for w in [x,y])
            L.append(word_pair)
    return L