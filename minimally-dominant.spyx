""" 
This code can be used to compute the set of dominant or minimally dominant elements of a conjugacy
class of a Weyl group W.
The final function in this file produces for such W a list of pairs of words (in GAP notation)
representing two elements for each (nonelliptic and nontrivial) conjugacy class of W: one is of
minimal length and the other one is minimally dominant. The pairs in this list, corresponding to
conjugacy classes, are separated by the string "end cc".

Input is:
. A Weyl group W (which in most auxiliary functions is assumed to be acting on its root lattice)

Input example:
> W = WeylGroup(["B",3])
> compute_pair_of_min_length_and_min_dom_elts(W) 

(The user may need to replace single quotes in the output with double quotes, in order to use it in
Julia with the other code in this repository.)
"""


def minimal_length_elts_of_set(X):
    min_length = min({x.length() for x in X})
    return {x for x in X if x.length() == min_length}


def minimally_dominant_elements_of_a_set(W, V, fundamental_weyl_chamber, Y):
    X = set()
    min_dom_length = W.long_element().length()
    for w in Y:
        if w.length() <= min_dom_length:
            if is_dominant(W, V, fundamental_weyl_chamber, w):
                if w.length() < min_dom_length:
                    min_dom_length = w.length()
                    X = {w}
                else:
                    X.add(w)
    return X


def is_dominant(W, V, fundamental_weyl_chamber, w):
    if w.reflection_length() == W.rank() or w.is_one():
        return True
    Vw = V_w(W, V, w)
    return Vw == V.span(intersect_closure_fundamental_cone_with_subspace(fundamental_weyl_chamber, Vw))


def fundamental_weyl_chamber_in_root_basis(W):
    return list(CartanMatrix(W.cartan_type()).inverse().transpose())


def intersect_closure_fundamental_cone_with_subspace(fundamental_weyl_chamber, subspace):
    fundamental_cone = Polyhedron(rays=fundamental_weyl_chamber, base_ring=AA)
    intersect_cone = fundamental_cone.intersection(Polyhedron(lines=subspace.basis(), base_ring=AA))
    return [ray.vector() for ray in intersect_cone.rays()]


def V_w(W, V, w):
    return V.span((w.to_matrix() - matrix.identity(W.rank())).columns())


def convert_word_from_bourbaki_to_gap(cartan_type, word):
    rk = cartan_type[1]
    if cartan_type[0] in {'B', 'C', 'D'}:
        dic = {i: rk - i + 1 for i in range(1, rk+1)}
    if cartan_type[0] in {'A', 'E', 'F', 'G'}:
        dic = {i: i for i in range(1, rk+1)}
    return [dic[word[i]] for i in range(len(word))]


def compute_pair_of_min_length_and_min_dom_elts(W):
    W = WeylGroup(RootSystem(W.cartan_type()).root_lattice())
    V = VectorSpace(AA, W.rank())
    cartan_type = W.cartan_type()
    fundamental_weyl_chamber = fundamental_weyl_chamber_in_root_basis(W)
    L = []
    for O in W.conjugacy_classes():
        if O[0].reflection_length() not in {0, W.rank()}:
            for x in minimally_dominant_elements_of_a_set(W, V, fundamental_weyl_chamber, O):
                break
            for y in minimal_length_elts_of_set(O):
                break
            L.append(convert_word_from_bourbaki_to_gap(
                cartan_type, x.reduced_word()))
            L.append(convert_word_from_bourbaki_to_gap(
                cartan_type, y.reduced_word()))
            L.append("end cc")
    return L